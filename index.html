<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mobile Whiteboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />

  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #f0f0f0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .toolbar {
      position: fixed;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background: rgba(255, 255, 255, 0.95);
      padding: 6px 10px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      font-size: 13px;
    }

    .toolbar label {
      display: flex;
      align-items: center;
      gap: 3px;
      white-space: nowrap;
    }

    .toolbar select,
    .toolbar input[type="color"],
    .toolbar input[type="range"],
    .toolbar button {
      border-radius: 999px;
      border: 1px solid #ccc;
      padding: 2px 6px;
      font-size: 12px;
      background: #fff;
    }

    .toolbar input[type="range"] {
      padding: 0;
    }

    .toolbar button {
      cursor: pointer;
    }

    #board {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      touch-action: none; /* important for custom touch handling */
      display: block;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <label>
      Tool
      <select id="tool">
        <option value="pen">Pen</option>
        <option value="eraser">Eraser</option>
      </select>
    </label>

    <label>
      Color
      <input type="color" id="color" value="#000000" />
    </label>

    <label>
      Size
      <input type="range" id="size" min="2" max="20" value="4" />
    </label>

    <button id="clear">Clear</button>
  </div>

  <canvas id="board"></canvas>

  <script>
    (function () {
      const canvas = document.getElementById("board");
      const ctx = canvas.getContext("2d");

      const toolSelect = document.getElementById("tool");
      const colorInput = document.getElementById("color");
      const sizeInput = document.getElementById("size");
      const clearBtn = document.getElementById("clear");

      let strokes = [];          // all strokes drawn (for infinite pan redraw)
      let currentStroke = null;  // stroke being drawn now

      let panX = 0;
      let panY = 0;

      let pointerMap = new Map(); // pointerId -> {x,y}
      let isPanning = false;
      let panStartMid = { x: 0, y: 0 };
      let panOrigin = { x: 0, y: 0 };
      let drawingPointerId = null;

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        redraw();
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function getWorldPos(e) {
        const rect = canvas.getBoundingClientRect();
        // world coordinates = screen coords minus pan offset
        return {
          x: (e.clientX - rect.left) - panX,
          y: (e.clientY - rect.top) - panY
        };
      }

      function redraw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        // apply pan
        ctx.translate(panX, panY);

        for (const stroke of strokes) {
          if (!stroke.points || stroke.points.length < 2) continue;

          ctx.lineJoin = "round";
          ctx.lineCap = "round";
          ctx.lineWidth = stroke.size;
          ctx.globalCompositeOperation =
            stroke.tool === "eraser" ? "destination-out" : "source-over";
          ctx.strokeStyle = stroke.tool === "eraser" ? "#000000" : stroke.color;

          ctx.beginPath();
          ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
          for (let i = 1; i < stroke.points.length; i++) {
            const p = stroke.points[i];
            ctx.lineTo(p.x, p.y);
          }
          ctx.stroke();
        }

        ctx.restore();
        ctx.globalCompositeOperation = "source-over";
      }

      function midpointOfPointers() {
        const values = Array.from(pointerMap.values());
        const a = values[0];
        const b = values[1];
        return {
          x: (a.x + b.x) / 2,
          y: (a.y + b.y) / 2
        };
      }

      canvas.addEventListener("pointerdown", function (e) {
        e.preventDefault();
        canvas.setPointerCapture(e.pointerId);
        pointerMap.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (pointerMap.size === 2) {
          // Start panning with two fingers
          isPanning = true;
          drawingPointerId = null;
          panOrigin = { x: panX, y: panY };
          panStartMid = midpointOfPointers();
        } else if (pointerMap.size === 1 && !isPanning) {
          // Start drawing with single pointer (finger/stylus/mouse)
          drawingPointerId = e.pointerId;
          const pos = getWorldPos(e);
          currentStroke = {
            tool: toolSelect.value,
            color: colorInput.value,
            size: parseInt(sizeInput.value, 10),
            points: [pos]
          };
          strokes.push(currentStroke);
          redraw();
        }
      }, { passive: false });

      canvas.addEventListener("pointermove", function (e) {
        if (!pointerMap.has(e.pointerId)) return;
        e.preventDefault();
        pointerMap.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (isPanning && pointerMap.size >= 2) {
          // Update pan based on middle of two fingers
          const mid = midpointOfPointers();
          panX = panOrigin.x + (mid.x - panStartMid.x);
          panY = panOrigin.y + (mid.y - panStartMid.y);
          redraw();
        } else if (drawingPointerId === e.pointerId && currentStroke) {
          const pos = getWorldPos(e);
          currentStroke.points.push(pos);
          redraw(); // simple and safe: redraw everything each move
        }
      }, { passive: false });

      function endPointer(e) {
        if (!pointerMap.has(e.pointerId)) return;
        e.preventDefault();
        pointerMap.delete(e.pointerId);

        if (isPanning) {
          if (pointerMap.size < 2) {
            isPanning = false;
          }
        }

        if (drawingPointerId === e.pointerId) {
          drawingPointerId = null;
          currentStroke = null;
        }
      }

      canvas.addEventListener("pointerup", endPointer, { passive: false });
      canvas.addEventListener("pointercancel", endPointer, { passive: false });
      canvas.addEventListener("pointerout", endPointer, { passive: false });
      canvas.addEventListener("pointerleave", endPointer, { passive: false });

      clearBtn.addEventListener("click", function () {
        strokes = [];
        redraw();
      });

      // Disable context menu (long press)
      canvas.addEventListener("contextmenu", function (e) {
        e.preventDefault();
      });
    })();
  </script>
</body>
</html>
